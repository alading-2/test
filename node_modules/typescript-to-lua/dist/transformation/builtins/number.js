"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformNumberPrototypeCall = transformNumberPrototypeCall;
exports.transformNumberProperty = transformNumberProperty;
exports.transformNumberConstructorCall = transformNumberConstructorCall;
const lua = require("../../LuaAST");
const lua_ast_1 = require("../utils/lua-ast");
const diagnostics_1 = require("../utils/diagnostics");
const lualib_1 = require("../utils/lualib");
const call_1 = require("../visitors/call");
const CompilerOptions_1 = require("../../CompilerOptions");
function transformNumberPrototypeCall(context, node, calledMethod) {
    const signature = context.checker.getResolvedSignature(node);
    const params = (0, call_1.transformArguments)(context, node.arguments, signature);
    const caller = context.transformExpression(calledMethod.expression);
    const expressionName = calledMethod.name.text;
    switch (expressionName) {
        case "toString":
            return params.length === 0
                ? lua.createCallExpression(lua.createIdentifier("tostring"), [caller], node)
                : (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.NumberToString, node, caller, ...params);
        case "toFixed":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.NumberToFixed, node, caller, ...params);
        default:
            context.diagnostics.push((0, diagnostics_1.unsupportedProperty)(calledMethod.name, "number", expressionName));
    }
}
function transformNumberProperty(context, node) {
    const name = node.name.text;
    /*
        Read the docs on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number for further info about what these numbers entail.
        Most of them should be fairly straight forward base on their name(s) though.
    */
    switch (name) {
        case "POSITIVE_INFINITY":
            if (context.luaTarget === CompilerOptions_1.LuaTarget.Lua50) {
                const one = lua.createNumericLiteral(1);
                const zero = lua.createNumericLiteral(0);
                return lua.createBinaryExpression(one, zero, lua.SyntaxKind.DivisionOperator);
            }
            else {
                const math = lua.createIdentifier("math");
                const huge = lua.createStringLiteral("huge");
                return lua.createTableIndexExpression(math, huge, node);
            }
        case "NEGATIVE_INFINITY":
            if (context.luaTarget === CompilerOptions_1.LuaTarget.Lua50) {
                const one = lua.createNumericLiteral(1);
                const zero = lua.createNumericLiteral(0);
                return lua.createUnaryExpression(lua.createBinaryExpression(one, zero, lua.SyntaxKind.DivisionOperator), lua.SyntaxKind.NegationOperator);
            }
            else {
                const math = lua.createIdentifier("math");
                const huge = lua.createStringLiteral("huge");
                return lua.createUnaryExpression(lua.createTableIndexExpression(math, huge, node), lua.SyntaxKind.NegationOperator);
            }
        case "NaN":
            return (0, lua_ast_1.createNaN)(node);
        case "EPSILON":
            return lua.createBinaryExpression(lua.createNumericLiteral(2), lua.createNumericLiteral(-52), lua.SyntaxKind.PowerOperator, node);
        case "MIN_VALUE":
            return lua.createBinaryExpression(lua.createNumericLiteral(-2), lua.createNumericLiteral(1074), lua.SyntaxKind.PowerOperator, node);
        case "MIN_SAFE_INTEGER":
            return lua.createBinaryExpression(lua.createNumericLiteral(-2), lua.createNumericLiteral(1074), lua.SyntaxKind.PowerOperator, node);
        case "MAX_SAFE_INTEGER":
            return lua.createBinaryExpression(lua.createNumericLiteral(2), lua.createNumericLiteral(1024), lua.SyntaxKind.PowerOperator, node);
        case "MAX_VALUE":
            return lua.createBinaryExpression(lua.createNumericLiteral(2), lua.createNumericLiteral(1024), lua.SyntaxKind.PowerOperator, node);
        default:
            context.diagnostics.push((0, diagnostics_1.unsupportedProperty)(node.name, "Number", name));
    }
}
function transformNumberConstructorCall(context, node, calledMethod) {
    const parameters = (0, call_1.transformArguments)(context, node.arguments);
    const methodName = calledMethod.name.text;
    switch (methodName) {
        case "isInteger":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.NumberIsInteger, node, ...parameters);
        case "isNaN":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.NumberIsNaN, node, ...parameters);
        case "isFinite":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.NumberIsFinite, node, ...parameters);
        case "parseInt":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.NumberParseInt, node, ...parameters);
        case "parseFloat":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.NumberParseFloat, node, ...parameters);
        default:
            context.diagnostics.push((0, diagnostics_1.unsupportedProperty)(calledMethod.name, "Number", methodName));
    }
}
//# sourceMappingURL=number.js.map